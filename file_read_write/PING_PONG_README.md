# Пинг-понг сервер

Простой TCP сервер с объектно-ориентированной архитектурой для игры в пинг-понг и передачи файлов.

## Описание

Сервер реализует следующий функционал:
- Чтение настроек из файла `settings.ini` (хост, порт, имя файла для передачи)
- Ожидание TCP подключения от клиента
- Автоматическая передача текстового файла после установки соединения
- Игра в пинг-понг с клиентом (обмен сообщениями)

## Архитектура

### Классы

1. **ConfigReader** - класс для чтения настроек из INI файла
   - Парсинг файла `settings.ini`
   - Валидация обязательных параметров
   - Предоставление настроек через геттеры

2. **PingPongServer** - основной класс сервера
   - Инициализация сетевых сокетов
   - Управление соединениями
   - Передача файлов
   - Логика пинг-понг игры

3. **PingPongClient** - класс клиента для тестирования
   - Подключение к серверу
   - Получение файлов от сервера
   - Участие в пинг-понг игре

## Файлы проекта

- `ping_pong_server.cpp` - основная реализация сервера
- `ping_pong_client.cpp` - клиент для тестирования
- `settings.ini` - файл конфигурации
- `test_message.txt` - тестовый файл для передачи клиенту

## Настройка

### Файл settings.ini

```ini
# Конфигурационный файл для пинг-понг сервера

# Адрес хоста (оставьте пустым для прослушивания всех интерфейсов)
host=localhost

# Порт для подключения
port=8080

# Имя файла для передачи клиенту после установки соединения
filename=test_message.txt
```

## Сборка

### Через CMake

```bash
mkdir build
cd build
cmake ..
make

# Или на Windows с Visual Studio:
cmake .. -G "Visual Studio 16 2019"
```

### Компиляция вручную

**Windows (с MinGW или Visual Studio):**
```cmd
g++ -o ping_pong_server ping_pong_server.cpp -lws2_32
g++ -o ping_pong_client ping_pong_client.cpp -lws2_32
```

**Linux/macOS:**
```bash
g++ -o ping_pong_server ping_pong_server.cpp
g++ -o ping_pong_client ping_pong_client.cpp
```

## Использование

### Запуск сервера

1. Убедитесь, что файл `settings.ini` существует и содержит правильные настройки
2. Убедитесь, что файл `test_message.txt` существует (или измените имя в настройках)
3. Запустите сервер:

```bash
./ping_pong_server
```

Сервер будет:
- Читать настройки из `settings.ini`
- Слушать подключения на указанном порту
- Ожидать подключения клиента

### Запуск клиента

В другом терминале запустите клиент:

```bash
./ping_pong_client
```

Клиент будет:
- Подключаться к серверу по адресу и порту из `settings.ini`
- Получать текстовый файл от сервера
- Играть в пинг-понг с сервером

## Пример работы

```
Сервер:
=== Пинг-понг сервер ===
Сервер запущен на localhost:8080
Ожидание подключения клиента...
Клиент подключен!
Файл test_message.txt отправлен клиенту (размер: 1024 байт)
Начинаем игру в пинг-понг!
Получено от клиента: PING #1 от клиента
Отправлено клиенту: PONG #1 от сервера
...

Клиент:
=== Пинг-понг клиент ===
Успешно подключились к серверу localhost:8080

=== Полученный файл от сервера ===
Добро пожаловать в пинг-понг сервер!
...
=== Конец файла ===

Начинаем игру в пинг-понг!
Отправлено серверу: PING #1 от клиента
Получено от сервера: PONG #1 от сервера
...
```

## Технические особенности

### Кроссплатформенность

- Автоматическое определение Windows/Linux через `#ifdef _WIN32`
- Использование соответствующих сетевых библиотек (Winsock/Linux sockets)
- Корректная инициализация и очистка ресурсов

### Обработка ошибок

- Проверка всех критических операций с сокетами
- Валидация конфигурационных файлов
- Корректное освобождение ресурсов в деструкторах

### Производительность

- Синхронная архитектура (подходит для учебных целей)
- Буферизованная передача файлов
- Управляемые размеры буферов сообщений

## Альтернативные решения

Как Senior разработчик, хочу отметить возможные улучшения:

1. **Асинхронность**: Использование `boost::asio` или `std::future` для неблокирующих операций
2. **Множественные клиенты**: Пул потоков для обслуживания нескольких подключений
3. **Безопасность**: TLS/SSL шифрование для производственного использования
4. **Протокол**: Custom binary protocol вместо plain text для лучшей производительности
5. **Логирование**: Структурированные логи с уровнями важности
6. **Конфигурация**: Использование библиотек типа `nlohmann/json` для сложных настроек

## Требования

- C++17 или новее
- Системная поддержка сокетов (Winsock на Windows, стандартные сокеты на Unix)
