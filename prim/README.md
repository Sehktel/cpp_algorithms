# Алгоритм Прима (Prim's Algorithm)

## Описание

Алгоритм Прима — это жадный алгоритм для построения **минимального остовного дерева (MST)** в связном неориентированном взвешенном графе. MST — это подграф, который соединяет все вершины с минимальной суммой весов рёбер и не содержит циклов.

## Ключевые особенности

- **Жадный алгоритм**: на каждом шаге выбирает ребро с минимальным весом
- **Использует приоритетную очередь**: для эффективного поиска минимального ребра
- **Временная сложность**: O(E log V) с приоритетной очередью
- **Пространственная сложность**: O(V)
- **Похож на алгоритм Дейкстры**: но строит дерево, а не находит пути

## Минимальное остовное дерево (MST)

### Определение
**Остовное дерево** (spanning tree) графа G — это подграф, который:
1. Включает **все вершины** графа G
2. Является **деревом** (связный граф без циклов)
3. Содержит **V-1 рёбер**, где V — количество вершин

**Минимальное остовное дерево** (MST) — это остовное дерево с минимальной суммой весов рёбер.

### Свойства MST
- В связном графе с V вершинами MST содержит ровно **V-1 рёбер**
- Если все веса рёбер различны, MST **единственно**
- Удаление любого ребра из MST делает граф **несвязным**
- Добавление любого ребра в MST создаёт **цикл**

## Как работает алгоритм

### Основная идея

1. Начинаем с произвольной вершины
2. На каждом шаге добавляем **самое лёгкое ребро**, соединяющее дерево с новой вершиной
3. Повторяем, пока не включим все вершины

### Алгоритм (псевдокод)

```
1. Инициализация:
   - Выбираем стартовую вершину s
   - key[s] = 0, key[v] = ∞ для всех остальных вершин
   - inMST[v] = false для всех вершин
   - Добавляем s в приоритетную очередь

2. Пока очередь не пуста:
   a) Извлекаем вершину u с минимальным key
   b) Если u уже в MST, пропускаем
   c) Добавляем u в MST
   d) Для каждого соседа v вершины u:
      - Если v не в MST и weight(u,v) < key[v]:
        * key[v] = weight(u,v)
        * Добавляем v в очередь с новым ключом

3. MST построено
```

## Пример работы

### Граф
```
    0
   /|\
  1 4 2
   \ /
    2
    |
    3
```

Веса рёбер: 0-1: 1, 0-2: 4, 1-2: 2, 2-3: 1

### Шаги алгоритма

1. **Начало**: выбираем вершину 0
   - MST: {0}
   - Рассматриваем рёбра: 0-1(1), 0-2(4)

2. **Шаг 1**: добавляем ребро 0-1 (вес 1)
   - MST: {0, 1}
   - Рассматриваем рёбра: 1-2(2), 0-2(4)

3. **Шаг 2**: добавляем ребро 1-2 (вес 2)
   - MST: {0, 1, 2}
   - Рассматриваем рёбра: 2-3(1)

4. **Шаг 3**: добавляем ребро 2-3 (вес 1)
   - MST: {0, 1, 2, 3}
   - **Готово!**

### Результат
```
MST рёбра: 0-1(1), 1-2(2), 2-3(1)
Общий вес: 4
```

## Сравнение с другими алгоритмами MST

| Алгоритм | Подход | Сложность | Лучше для |
|----------|--------|-----------|-----------|
| **Prim** | Жадный (растёт от вершины) | O(E log V) | Плотные графы |
| **Kruskal** | Жадный (сортирует рёбра) | O(E log E) | Разреженные графы |
| **Borůvka** | Параллельный | O(E log V) | Параллельные вычисления |

## Сравнение Прима и Дейкстры

| Параметр | Prim | Dijkstra |
|----------|------|----------|
| **Задача** | Минимальное остовное дерево | Кратчайшие пути |
| **Ключ** | Вес ребра до вершины | Расстояние от источника |
| **Результат** | Дерево с V-1 рёбрами | Расстояния до всех вершин |
| **Граф** | Неориентированный | Ориентированный/неориент. |
| **Накопление** | Нет (только вес ребра) | Да (сумма весов пути) |

## Когда использовать

### ✅ Хорошо подходит для:
- Построения сетей с минимальной стоимостью
- Плотных графов (много рёбер относительно вершин)
- Когда нужно соединить все точки с минимальными затратами
- Задач кластеризации
- Приближённых алгоритмов (TSP, Steiner tree)

### ❌ Не подходит для:
- Несвязных графов (MST не существует)
- Ориентированных графов
- Когда нужны пути между конкретными вершинами
- Разреженных графов (лучше использовать Kruskal)

## Применение

1. **Сетевой дизайн**
   - Прокладка электрических/телефонных линий
   - Проектирование трубопроводов
   - Компьютерные сети

2. **Кластерный анализ**
   - Группировка данных
   - Сегментация изображений

3. **Приближённые алгоритмы**
   - Задача коммивояжёра (TSP)
   - Задача Штейнера

4. **Биоинформатика**
   - Анализ генетических данных
   - Построение филогенетических деревьев

5. **География**
   - Планирование дорог
   - Оптимизация маршрутов

## Компиляция и запуск

```bash
# Компиляция
g++ -std=c++11 -o prim simple_prim.cxx

# Запуск
./prim
```

## Особенности реализации

### Режим verbose
Программа поддерживает детальный вывод:
- Показывает каждый шаг добавления вершины
- Выводит состояние приоритетной очереди
- Показывает обновления ключей
- Визуализирует текущее состояние MST

### Приоритетная очередь
Используется `std::priority_queue` с компаратором `greater` для извлечения минимального элемента.

### Проверка корректности
После построения MST проверяется, что количество рёбер равно V-1.

## Временная сложность

- **O(E log V)** с приоритетной очередью (binary heap)
- **O(E + V log V)** с фибоначчиевой кучей
- **O(V²)** с простым поиском минимума

Для плотных графов (E ≈ V²): O(V² log V)
Для разреженных графов (E ≈ V): O(V log V)

## Пространственная сложность

- **O(V)**: для массивов key, parent, inMST
- **O(E)**: для списка смежности
- **O(V)**: для приоритетной очереди
- **Итого**: O(V + E)

## Корректность алгоритма

### Теорема (Cut Property)
Пусть S ⊂ V — подмножество вершин графа. Если ребро e имеет минимальный вес среди всех рёбер, соединяющих S и V\S, то e принадлежит некоторому MST.

### Доказательство жадного выбора
Алгоритм Прима на каждом шаге выбирает ребро с минимальным весом, соединяющее MST с новой вершиной. По Cut Property, это ребро обязательно войдёт в некоторое MST.

## Вариации алгоритма

### 1. Версия с матрицей смежности
```cpp
// Проще для плотных графов
for (int i = 0; i < V; i++) {
    int minKey = INT_MAX, minIndex;
    for (int v = 0; v < V; v++)
        if (!inMST[v] && key[v] < minKey)
            minKey = key[v], minIndex = v;
    // ... обработка minIndex
}
```
Сложность: O(V²)

### 2. Версия с фибоначчиевой кучей
- Decrease-key за O(1) амортизированно
- Общая сложность: O(E + V log V)

## Оптимизации

1. **Выбор стартовой вершины**: не влияет на результат, но может ускорить работу
2. **Ленивое удаление из очереди**: не удаляем устаревшие записи, проверяем при извлечении
3. **Фибоначчиева куча**: для очень больших графов

## Интересные факты

- Назван в честь Роберта Прима (1957)
- Независимо открыт Войцехом Ярником (1930) и Эдсгером Дейкстрой (1959)
- Может работать с любой начальной вершины — результат будет одинаковым
- В плотных графах эффективнее алгоритма Крускала

## Связь с другими алгоритмами

- **Алгоритм Дейкстры**: похожая структура, но разные задачи
- **Алгоритм Крускала**: другой подход к MST (сортирует рёбра)
- **Алгоритм Борувки**: параллельная версия MST
- **Жадные алгоритмы**: Prim — классический пример жадного подхода

## Дополнительные задачи

1. Модифицировать для поиска максимального остовного дерева
2. Найти второе по величине MST
3. Вычислить bottleneck spanning tree
4. Построить MST с ограничениями (degree-constrained MST)
5. Динамический MST (обновление при добавлении/удалении рёбер)

## Доказательство оптимальности

### Лемма о безопасном ребре
Если A — подмножество некоторого MST, и (u,v) — лёгкое ребро, пересекающее разрез (S, V-S), где A не пересекает разрез, то (u,v) безопасно для A.

**Алгоритм Прима** на каждом шаге добавляет безопасное ребро, поэтому строит MST.

