#include <iostream>

// ========================================================================
// КРАСНО-ЧЕРНОЕ ДЕРЕВО (Red-Black Tree)
// ========================================================================
// Красно-черное дерево - это самобалансирующееся бинарное дерево поиска,
// которое использует дополнительную информацию о цвете каждого узла для
// поддержания баланса.
//
// ОСНОВНЫЕ СВОЙСТВА (инварианты):
// 1. Каждый узел либо КРАСНЫЙ, либо ЧЕРНЫЙ
// 2. КОРЕНЬ всегда ЧЕРНЫЙ
// 3. Все ЛИСТЬЯ (nil) ЧЕРНЫЕ
// 4. Если узел КРАСНЫЙ, то оба его потомка ЧЕРНЫЕ
//    (нет двух красных узлов подряд)
// 5. Все пути от узла до листьев содержат ОДИНАКОВОЕ число черных узлов
//    (черная высота одинакова для всех путей)
//
// ПРЕИМУЩЕСТВА перед AVL:
// - Меньше поворотов при вставке/удалении (в среднем)
// - Более эффективно для частых операций записи
// - Используется в std::map, std::set в C++
//
// НЕДОСТАТКИ:
// - Может быть менее сбалансированным, чем AVL (высота до 2*log(n))
// - Сложнее реализация из-за большего количества случаев
// ========================================================================

// Цвет узла в красно-черном дереве
enum Color { RED, BLACK };

// Узел красно-черного дерева
// ОТЛИЧИЕ от AVL: храним не высоту, а цвет и указатель на родителя
struct RBNode
{
    int data;
    Color color;        // Цвет узла (RED или BLACK)
    RBNode* left;        // Левый потомок
    RBNode* right;       // Правый потомок
    RBNode* parent;      // Родитель (нужен для балансировки)
    
    // Новые узлы всегда вставляются КРАСНЫМИ
    // Это может нарушить свойство 4 (два красных подряд), но это исправляется
    RBNode(int val) : data(val), color(RED), left(nullptr), right(nullptr), parent(nullptr) {}
};

// Класс красно-черного дерева
class RedBlackTree
{
    RBNode* root;
    RBNode* nil;  // Специальный узел-лист (черный)
    bool verbose;

    // Вспомогательная функция для вывода цвета
    std::string getColorName(Color c)
    {
        return (c == RED) ? "КРАСНЫЙ" : "ЧЕРНЫЙ";
    }

    // ========================================================================
    // БАЗОВЫЕ ПОВОРОТЫ
    // ========================================================================
    // В красно-черном дереве используются те же два базовых поворота, что и в AVL:
    // 1. Левый поворот (leftRotate)
    // 2. Правый поворот (rightRotate)
    //
    // ОТЛИЧИЕ от AVL: нужно обновлять указатели parent для всех затронутых узлов,
    // так как красно-черное дерево использует родительские указатели для балансировки.
    // ========================================================================

    // Левый поворот (Left Rotate) - базовый примитив #1
    // Используется для исправления правого перевеса
    //
    // Визуализация:
    //      x                      y
    //     / \                    / \
    //    T1  y        =>        x   T3
    //       / \                / \
    //      T2  T3             T1  T2
    //
    // ВАЖНО: Обновляем parent для всех узлов, которые меняют позицию
    void leftRotate(RBNode* x)
    {
        if (verbose)
            std::cout << "  [БАЗОВЫЙ] Левый поворот вокруг " << x->data << std::endl;
        
        RBNode* y = x->right;      // Правый потомок x становится новым корнем
        x->right = y->left;        // Левое поддерево y становится правым поддеревом x
        
        // Обновляем parent для T2 (если оно существует)
        if (y->left != nil)
            y->left->parent = x;
        
        // Обновляем parent для y (он теперь на месте x)
        y->parent = x->parent;
        
        // Обновляем указатель родителя на новый узел y
        if (x->parent == nil)
            root = y;              // x был корнем
        else if (x == x->parent->left)
            x->parent->left = y;   // x был левым потомком
        else
            x->parent->right = y;  // x был правым потомком
        
        // Завершаем поворот: x становится левым потомком y
        y->left = x;
        x->parent = y;
    }

    // Правый поворот (Right Rotate) - базовый примитив #2
    // Используется для исправления левого перевеса
    //
    // Визуализация:
    //        y                  x
    //       / \                / \
    //      x   T3    =>      T1   y
    //     / \                    / \
    //    T1  T2                 T2  T3
    //
    // ВАЖНО: Обновляем parent для всех узлов, которые меняют позицию
    void rightRotate(RBNode* y)
    {
        if (verbose)
            std::cout << "  [БАЗОВЫЙ] Правый поворот вокруг " << y->data << std::endl;
        
        RBNode* x = y->left;       // Левый потомок y становится новым корнем
        y->left = x->right;        // Правое поддерево x становится левым поддеревом y
        
        // Обновляем parent для T2 (если оно существует)
        if (x->right != nil)
            x->right->parent = y;
        
        // Обновляем parent для x (он теперь на месте y)
        x->parent = y->parent;
        
        // Обновляем указатель родителя на новый узел x
        if (y->parent == nil)
            root = x;              // y был корнем
        else if (y == y->parent->left)
            y->parent->left = x;   // y был левым потомком
        else
            y->parent->right = x;  // y был правым потомком
        
        // Завершаем поворот: y становится правым потомком x
        x->right = y;
        y->parent = x;
    }

    // ========================================================================
    // ИСПРАВЛЕНИЕ НАРУШЕНИЙ ПОСЛЕ ВСТАВКИ (insertFixup)
    // ========================================================================
    // ПРОБЛЕМА: Новый узел всегда вставляется КРАСНЫМ. Это может нарушить
    // свойство 4: "Если узел красный, оба его потомка черные".
    //
    // НАПРАВЛЕНИЕ ПРОВЕРКИ: СНИЗУ ВВЕРХ (bottom-up)
    // - Начинаем с вставленного узла z
    // - Поднимаемся вверх по дереву, пока не исправим все нарушения
    // - Цикл продолжается, пока parent(z) красный
    //
    // ТРИ СЛУЧАЯ БАЛАНСИРОВКИ:
    // Случай 1: ДЯДЯ (uncle) КРАСНЫЙ
    //   - Решение: ПЕРЕКРАШИВАНИЕ (без поворотов)
    //   - Родитель и дядя → черные, дедушка → красный
    //   - Переходим к дедушке (может потребоваться дальнейшая балансировка)
    //
    // Случай 2: ДЯДЯ ЧЕРНЫЙ, z - "внутренний" потомок (не на прямой линии)
    //   - Решение: ПОВОРОТ вокруг родителя (приводит к случаю 3)
    //   - После поворота z становится "внешним" потомком
    //
    // Случай 3: ДЯДЯ ЧЕРНЫЙ, z - "внешний" потомок (на прямой линии)
    //   - Решение: ПЕРЕКРАШИВАНИЕ + ПОВОРОТ вокруг дедушки
    //   - Это финальный случай, после него балансировка завершается
    //
    // ВИЗУАЛЬНЫЕ ПРИМЕРЫ:
    //
    // СЛУЧАЙ 1 (дядя красный):
    //         B(дедушка)              R(дедушка)
    //        /         \              /         \
    //    R(родитель)  R(дядя)  =>  B(родитель) B(дядя)
    //      /                         /
    //   R(z)                      R(z)
    // Перекрашиваем: родитель→черный, дядя→черный, дедушка→красный
    // Продолжаем с дедушкой (может быть нарушение выше)
    //
    // СЛУЧАЙ 2 (дядя черный, z правый потомок):
    //         B(дедушка)              B(дедушка)
    //        /         \              /         \
    //    R(родитель)  B(дядя)  =>  R(z)       B(дядя)
    //        \                      /
    //       R(z)              R(родитель)
    // Поворачиваем вокруг родителя → получаем случай 3
    //
    // СЛУЧАЙ 3 (дядя черный, z левый потомок):
    //         B(дедушка)              B(родитель)
    //        /         \              /         \
    //    R(родитель)  B(дядя)  =>  R(z)       R(дедушка)
    //      /                                    \
    //   R(z)                                   B(дядя)
    // Перекрашиваем: родитель→черный, дедушка→красный
    // Поворачиваем вокруг дедушки → балансировка завершена
    // ========================================================================
    void insertFixup(RBNode* z)
    {
        // Цикл продолжается, пока родитель z красный (нарушение свойства 4)
        // Если parent черный или z - корень, нарушений нет
        while (z->parent->color == RED)
        {
            // Определяем, на какой стороне находится родитель z
            if (z->parent == z->parent->parent->left)
            {
                // Родитель - левый потомок дедушки
                RBNode* y = z->parent->parent->right;  // ДЯДЯ (uncle)
                
                // ========== СЛУЧАЙ 1: ДЯДЯ КРАСНЫЙ ==========
                // Проблема: два красных подряд (родитель и z)
                // Решение: ПЕРЕКРАШИВАНИЕ (без поворотов)
                // - Родитель → черный
                // - Дядя → черный
                // - Дедушка → красный
                // - Переходим к дедушке (может потребоваться дальнейшая балансировка)
                if (y->color == RED)
                {
                    if (verbose)
                        std::cout << "  [СЛУЧАЙ 1] Дядя красный: перекрашиваем (родитель→B, дядя→B, дедушка→R)" << std::endl;
                    z->parent->color = BLACK;          // Родитель → черный
                    y->color = BLACK;                  // Дядя → черный
                    z->parent->parent->color = RED;    // Дедушка → красный
                    z = z->parent->parent;            // Переходим к дедушке (проверяем выше)
                }
                else
                {
                    // ========== СЛУЧАЙ 2: ДЯДЯ ЧЕРНЫЙ, z - ПРАВЫЙ ПОТОМОК ==========
                    // Проблема: z - "внутренний" потомок (не на прямой линии от дедушки)
                    // Решение: ПОВОРОТ вокруг родителя (превращает в случай 3)
                    // После поворота z становится "внешним" потомком
                    if (z == z->parent->right)
                    {
                        if (verbose)
                            std::cout << "  [СЛУЧАЙ 2] Дядя черный, z правый потомок: поворот вокруг родителя" << std::endl;
                        z = z->parent;                 // Переходим к родителю
                        leftRotate(z);                 // Левый поворот (z теперь левый потомок)
                    }
                    // ========== СЛУЧАЙ 3: ДЯДЯ ЧЕРНЫЙ, z - ЛЕВЫЙ ПОТОМОК ==========
                    // Проблема: z - "внешний" потомок (на прямой линии от дедушки)
                    // Решение: ПЕРЕКРАШИВАНИЕ + ПОВОРОТ вокруг дедушки
                    // Это финальный случай - после него балансировка завершается
                    if (verbose)
                        std::cout << "  [СЛУЧАЙ 3] Дядя черный, z левый потомок: перекрашивание + поворот" << std::endl;
                    z->parent->color = BLACK;          // Родитель → черный
                    z->parent->parent->color = RED;   // Дедушка → красный
                    rightRotate(z->parent->parent);    // Правый поворот вокруг дедушки
                }
            }
            else
            {
                // ========== СИММЕТРИЧНЫЙ СЛУЧАЙ: Родитель - ПРАВЫЙ потомок дедушки ==========
                // Все то же самое, но зеркально отражено
                RBNode* y = z->parent->parent->left;   // ДЯДЯ (uncle) - теперь слева
                
                // СЛУЧАЙ 1 (симметричный): Дядя красный
                if (y->color == RED)
                {
                    if (verbose)
                        std::cout << "  [СЛУЧАЙ 1 симметричный] Дядя красный: перекрашиваем" << std::endl;
                    z->parent->color = BLACK;
                    y->color = BLACK;
                    z->parent->parent->color = RED;
                    z = z->parent->parent;
                }
                else
                {
                    // СЛУЧАЙ 2 (симметричный): Дядя черный, z - ЛЕВЫЙ потомок
                    if (z == z->parent->left)
                    {
                        if (verbose)
                            std::cout << "  [СЛУЧАЙ 2 симметричный] Дядя черный, z левый потомок: поворот" << std::endl;
                        z = z->parent;
                        rightRotate(z);                // Правый поворот (симметрично)
                    }
                    // СЛУЧАЙ 3 (симметричный): Дядя черный, z - ПРАВЫЙ потомок
                    if (verbose)
                        std::cout << "  [СЛУЧАЙ 3 симметричный] Дядя черный, z правый потомок: перекрашивание + поворот" << std::endl;
                    z->parent->color = BLACK;
                    z->parent->parent->color = RED;
                    leftRotate(z->parent->parent);    // Левый поворот (симметрично)
                }
            }
        }
        // ГАРАНТИЯ: Корень всегда черный (свойство 2)
        // Если в процессе балансировки корень стал красным, делаем его черным
        root->color = BLACK;
    }

    // ========================================================================
    // КАК ВРУЧНУЮ РАСПОЗНАТЬ СЛУЧАЙ БАЛАНСИРОВКИ?
    // ========================================================================
    // Алгоритм определения случая (пошагово):
    //
    // ШАГ 1: Проверьте цвет родителя z
    //   - Если parent(z) ЧЕРНЫЙ → нарушений нет, балансировка не нужна
    //   - Если parent(z) КРАСНЫЙ → есть нарушение свойства 4, нужна балансировка
    //
    // ШАГ 2: Определите, на какой стороне находится родитель
    //   - Если parent == grandparent->left → родитель слева
    //   - Если parent == grandparent->right → родитель справа
    //
    // ШАГ 3: Найдите дядю (uncle) и проверьте его цвет
    //   - Если parent слева → uncle = grandparent->right
    //   - Если parent справа → uncle = grandparent->left
    //
    // ШАГ 4: Определите случай по цвету дяди и позиции z
    //
    //   СЛУЧАЙ 1: uncle КРАСНЫЙ
    //     - Решение: ПЕРЕКРАШИВАНИЕ (родитель→B, дядя→B, дедушка→R)
    //     - Переходим к дедушке (может потребоваться дальнейшая балансировка)
    //
    //   СЛУЧАЙ 2: uncle ЧЕРНЫЙ И z - "внутренний" потомок
    //     - Если parent слева: z == parent->right (z справа от родителя)
    //     - Если parent справа: z == parent->left (z слева от родителя)
    //     - Решение: ПОВОРОТ вокруг parent (приводит к случаю 3)
    //
    //   СЛУЧАЙ 3: uncle ЧЕРНЫЙ И z - "внешний" потомок
    //     - Если parent слева: z == parent->left (z слева от родителя)
    //     - Если parent справа: z == parent->right (z справа от родителя)
    //     - Решение: ПЕРЕКРАШИВАНИЕ + ПОВОРОТ вокруг grandparent
    //
    // ПРИМЕРЫ:
    //
    // Пример 1 (Случай 1):
    //         B(50)                    R(50)
    //        /    \                   /    \
    //    R(30)   R(70)    =>      B(30)  B(70)
    //      /                        /
    //   R(20)                    R(20)
    // Дядя 70 красный → перекрашиваем, переходим к 50
    //
    // Пример 2 (Случай 2→3):
    //         B(50)                    B(50)                    B(30)
    //        /    \                   /    \                   /      \
    //    R(30)   B(70)    =>      R(20)   B(70)    =>      R(20)    R(50)
    //        \                    /                              \      \
    //       R(20)            R(30)                            nil    B(70)
    // Дядя 70 черный, z=20 правый → поворот вокруг 30 (случай 2)
    // Затем перекрашивание + поворот вокруг 50 (случай 3)
    // ========================================================================

    // ========================================================================
    // ВСТАВКА УЗЛА
    // ========================================================================
    // ПРОЦЕСС:
    // 1. Находим место для вставки (как в обычном BST)
    // 2. Вставляем узел КРАСНЫМ (может нарушить свойство 4)
    // 3. Вызываем insertFixup для исправления нарушений
    //
    // НАПРАВЛЕНИЕ БАЛАНСИРОВКИ: СНИЗУ ВВЕРХ (bottom-up)
    // - Начинаем с вставленного узла z
    // - Поднимаемся вверх по дереву (z → parent → grandparent → ...)
    // - Исправляем нарушения на каждом уровне
    // - Может потребоваться несколько итераций (в случае 1)
    // - В худшем случае поднимаемся до корня: O(log n) итераций
    //
    // ДЕРЕВО ВСЕГДА БАЛАНСИРУЕТСЯ ПО МЕРЕ ДОБАВЛЕНИЯ ВЕРШИН
    // Каждая вставка проверяет и восстанавливает свойства красно-черного дерева.
    // После каждой операции дерево остается сбалансированным.
    //
    // ЧТО ЕСЛИ ДЕРЕВО УЖЕ ЗАДАНО (несбалансированное)?
    // Аналогично AVL, есть два подхода:
    // 1. Построить заново: собрать элементы через inorder, вставить по одному
    // 2. Использовать алгоритм преобразования (более сложно)
    // В данной реализации используется подход 1: все элементы вставляются
    // по одному через insert(), который автоматически поддерживает баланс.
    // ========================================================================
    void insertHelper(RBNode* z)
    {
        RBNode* y = nil;    // Будет хранить родителя для нового узла
        RBNode* x = root;   // Текущий узел при поиске
        
        // ========== ЭТАП 1: Поиск места для вставки (как в обычном BST) ==========
        while (x != nil)
        {
            y = x;  // Сохраняем текущий узел как потенциального родителя
            if (z->data < x->data)
                x = x->left;
            else
                x = x->right;
        }
        
        // ========== ЭТАП 2: Вставка узла ==========
        z->parent = y;
        if (y == nil)
            root = z;                    // Дерево было пустым, z становится корнем
        else if (z->data < y->data)
            y->left = z;                 // z меньше родителя → левый потомок
        else
            y->right = z;                // z больше родителя → правый потомок
        
        // Инициализируем потомков как nil (листья)
        z->left = nil;
        z->right = nil;
        z->color = RED;                  // ВАЖНО: новый узел всегда КРАСНЫЙ
        
        if (verbose)
            std::cout << "  Вставлен узел " << z->data << " (красный)" << std::endl;
        
        // ========== ЭТАП 3: Исправление нарушений свойств красно-черного дерева ==========
        // Если parent(z) красный, это нарушает свойство 4
        // insertFixup исправит это, поднимаясь вверх по дереву
        insertFixup(z);
    }

    // Обход inorder
    void inorderHelper(RBNode* node)
    {
        if (node != nil)
        {
            inorderHelper(node->left);
            std::cout << node->data << "(" << getColorName(node->color) << ") ";
            inorderHelper(node->right);
        }
    }

    // Визуализация дерева
    void printTreeHelper(RBNode* node, int level, const std::string& prefix)
    {
        if (node != nil)
        {
            printTreeHelper(node->right, level + 1, prefix + "    ");
            
            std::cout << prefix;
            std::cout << node->data;
            if (node->color == RED)
                std::cout << "(R)";
            else
                std::cout << "(B)";
            std::cout << std::endl;
            
            printTreeHelper(node->left, level + 1, prefix + "    ");
        }
    }

    // Уничтожение дерева
    void destroyTree(RBNode* node)
    {
        if (node != nil)
        {
            destroyTree(node->left);
            destroyTree(node->right);
            delete node;
        }
    }

    // ========================================================================
    // ПЕРЕКРАШИВАНИЕ ВЕРШИН (Recoloring)
    // ========================================================================
    // Перекрашивание - это операция изменения цвета узлов без изменения
    // структуры дерева (без поворотов).
    //
    // КОГДА ИСПОЛЬЗУЕТСЯ:
    // - В СЛУЧАЕ 1: когда дядя красный
    //   - Родитель → черный
    //   - Дядя → черный
    //   - Дедушка → красный
    //   - Это "проталкивает" проблему вверх (дедушка может стать красным)
    //
    // - В СЛУЧАЕ 3: перед поворотом
    //   - Родитель → черный
    //   - Дедушка → красный
    //   - Затем выполняется поворот
    //
    // ПОЧЕМУ ПЕРЕКРАШИВАНИЕ, А НЕ ПОВОРОТ?
    // - Перекрашивание не меняет структуру дерева (O(1))
    // - Поворот меняет структуру (O(1), но сложнее)
    // - В случае 1 перекрашивание достаточно, так как проблема "уходит" вверх
    // - В случае 3 перекрашивание + поворот окончательно решают проблему
    //
    // МОЖЕТ ЛИ ПОТРЕБОВАТЬСЯ НЕСКОЛЬКО ПЕРЕКРАШИВАНИЙ?
    // Да! В случае 1 мы переходим к дедушке, который стал красным.
    // Если его родитель тоже красный, цикл продолжается.
    // В худшем случае можем подняться до корня (O(log n) итераций).
    //
    // СРАВНЕНИЕ С AVL:
    // - AVL: использует только ПОВОРОТЫ (меняет структуру)
    // - RB: использует ПЕРЕКРАШИВАНИЕ (чаще) и ПОВОРОТЫ (реже)
    // - RB: меньше поворотов в среднем, но может потребоваться больше итераций
    // ========================================================================

public:
    RedBlackTree(bool verboseMode = false) : verbose(verboseMode)
    {
        nil = new RBNode(0);
        nil->color = BLACK;
        root = nil;
    }

    ~RedBlackTree()
    {
        destroyTree(root);
        delete nil;
    }

    void insert(int val)
    {
        if (verbose)
            std::cout << "Вставка " << val << ":" << std::endl;
        RBNode* z = new RBNode(val);
        insertHelper(z);
    }

    void inorder()
    {
        std::cout << "Inorder обход: ";
        inorderHelper(root);
        std::cout << std::endl;
    }

    void printTree()
    {
        std::cout << "\nСтруктура красно-черного дерева (повернуто на 90°):" << std::endl;
        std::cout << "R=красный, B=черный" << std::endl;
        printTreeHelper(root, 0, "");
    }
};

int main()
{
    std::cout << "========================================" << std::endl;
    std::cout << "  ТЕСТ 1: Красно-черное дерево - вставка" << std::endl;
    std::cout << "========================================" << std::endl;
    
    RedBlackTree rbt1(true);
    
    std::cout << "\n--- Вставка элементов ---" << std::endl;
    std::cout << "Вставляем 10 (корень, становится черным)" << std::endl;
    rbt1.insert(10);
    rbt1.printTree();
    
    std::cout << "\nВставляем 20 (красный, нарушений нет)" << std::endl;
    rbt1.insert(20);
    rbt1.printTree();
    
    std::cout << "\nВставляем 30 (красный, вызовет случай 3: перекрашивание + поворот)" << std::endl;
    rbt1.insert(30);
    rbt1.printTree();
    
    std::cout << "\nВставляем 5 (красный, нарушений нет)" << std::endl;
    rbt1.insert(5);
    rbt1.printTree();
    
    std::cout << "\nВставляем 15 (красный, может вызвать случай 1: перекрашивание)" << std::endl;
    rbt1.insert(15);
    rbt1.printTree();
    
    std::cout << "\nВставляем 25, 35" << std::endl;
    rbt1.insert(25);
    rbt1.insert(35);
    rbt1.printTree();
    rbt1.inorder();
    
    std::cout << "\n\n========================================" << std::endl;
    std::cout << "  ТЕСТ 2: Вставка в порядке возрастания" << std::endl;
    std::cout << "========================================" << std::endl;
    
    RedBlackTree rbt2(false);
    std::cout << "Вставка в порядке возрастания (1-7) в красно-черное дерево:" << std::endl;
    for (int i = 1; i <= 7; i++)
    {
        rbt2.insert(i);
    }
    rbt2.printTree();
    rbt2.inorder();
    
    std::cout << "\n\n========================================" << std::endl;
    std::cout << "  ТЕСТ 3: Большое дерево" << std::endl;
    std::cout << "========================================" << std::endl;
    
    RedBlackTree rbt3(false);
    int values[] = {50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45, 55, 65, 75, 85};
    std::cout << "Вставка множества элементов:" << std::endl;
    for (int val : values)
    {
        rbt3.insert(val);
    }
    rbt3.printTree();
    
    std::cout << "\n\n========================================" << std::endl;
    std::cout << "  ТЕСТ 4: Ручное распознавание случаев балансировки" << std::endl;
    std::cout << "========================================" << std::endl;
    
    RedBlackTree rbt4(true);
    std::cout << "\nПример: Случай 1 (дядя красный - перекрашивание)" << std::endl;
    std::cout << "Вставляем: 50, 30, 70, 20" << std::endl;
    std::cout << "Анализ при вставке 20:" << std::endl;
    std::cout << "  1. parent(20) = 30 (красный) → нарушение свойства 4" << std::endl;
    std::cout << "  2. parent слева от grandparent(50)" << std::endl;
    std::cout << "  3. uncle = 70 (красный) → СЛУЧАЙ 1" << std::endl;
    std::cout << "  4. Решение: перекрашивание (30→B, 70→B, 50→R)" << std::endl;
    rbt4.insert(50);
    rbt4.insert(30);
    rbt4.insert(70);
    rbt4.insert(20);
    rbt4.printTree();
    
    std::cout << "\n\n========================================" << std::endl;
    std::cout << "  ТЕСТ 5: Случай 2→3 (поворот + перекрашивание)" << std::endl;
    std::cout << "========================================" << std::endl;
    
    RedBlackTree rbt5(true);
    std::cout << "Вставляем: 50, 30, 20" << std::endl;
    std::cout << "Анализ при вставке 20:" << std::endl;
    std::cout << "  1. parent(20) = 30 (красный) → нарушение" << std::endl;
    std::cout << "  2. parent слева от grandparent(50)" << std::endl;
    std::cout << "  3. uncle = nil (черный) → не случай 1" << std::endl;
    std::cout << "  4. z=20 левый потомок parent(30) → СЛУЧАЙ 3" << std::endl;
    std::cout << "  5. Решение: перекрашивание (30→B, 50→R) + поворот вокруг 50" << std::endl;
    rbt5.insert(50);
    rbt5.insert(30);
    rbt5.insert(20);
    rbt5.printTree();
    
    std::cout << "\n\n========================================" << std::endl;
    std::cout << "  СРАВНЕНИЕ С AVL ДЕРЕВОМ" << std::endl;
    std::cout << "========================================" << std::endl;
    std::cout << "КРАСНО-ЧЕРНОЕ ДЕРЕВО:" << std::endl;
    std::cout << "  + Меньше поворотов в среднем (чаще перекрашивание)" << std::endl;
    std::cout << "  + Эффективнее для частых операций записи" << std::endl;
    std::cout << "  + Используется в std::map, std::set (C++)" << std::endl;
    std::cout << "  - Может быть менее сбалансированным (высота до 2*log(n))" << std::endl;
    std::cout << "  - Сложнее реализация (больше случаев)" << std::endl;
    std::cout << "  - Требует хранения parent указателей" << std::endl;
    std::cout << std::endl;
    std::cout << "AVL ДЕРЕВО:" << std::endl;
    std::cout << "  + Более строгий баланс (высота <= 1.44*log(n))" << std::endl;
    std::cout << "  + Быстрее поиск (более сбалансированное)" << std::endl;
    std::cout << "  + Проще реализация (только повороты)" << std::endl;
    std::cout << "  - Больше поворотов при вставке/удалении" << std::endl;
    std::cout << "  - Медленнее операции записи" << std::endl;
    std::cout << "  - Не требует parent указателей" << std::endl;
    
    std::cout << "\n\n=== ВЫВОД ===" << std::endl;
    std::cout << "Красно-черное дерево (Red-Black Tree):" << std::endl;
    std::cout << "- Самобалансирующееся бинарное дерево поиска" << std::endl;
    std::cout << "- Свойства красно-черного дерева:" << std::endl;
    std::cout << "  1. Каждый узел либо красный, либо черный" << std::endl;
    std::cout << "  2. Корень всегда черный" << std::endl;
    std::cout << "  3. Листья (nil) черные" << std::endl;
    std::cout << "  4. Если узел красный, оба его потомка черные" << std::endl;
    std::cout << "  5. Все пути от узла до листьев содержат одинаковое число черных узлов" << std::endl;
    std::cout << "- Высота дерева: O(log n), максимум 2*log(n+1)" << std::endl;
    std::cout << "- Все операции: O(log n)" << std::endl;
    std::cout << "- Используется в std::map и std::set в C++" << std::endl;
    std::cout << "- Балансировка: перекрашивание (чаще) + повороты (реже)" << std::endl;
    std::cout << "- Три случая балансировки при вставке" << std::endl;
    
    return 0;
}


