# Примеры работы алгоритма Флойда-Уоршелла

## Обзор тестов

В файле `simple_floyd_warshall.cxx` реализовано 12 тестовых примеров, демонстрирующих различные аспекты работы алгоритма. Каждый тест показывает уникальный сценарий использования.

---

## ТЕСТ 1: Простой направленный граф

### Описание
Базовый пример с направленным графом из 4 вершин.

### Граф
```
    0 --4--> 1
    |        |
    2        1
    |        |
    ↓        ↓
    2 --2--> 3
```

### Особенности
- Демонстрирует базовую работу алгоритма
- Показывает улучшение пути 0→3 через промежуточную вершину 2
- Прямого пути 0→3 нет, но алгоритм находит путь 0→2→3

### Результат
- Путь 0→3: `0 → 2 → 3` (длина: 4)
- Путь 0→1: `0 → 1` (длина: 4)

---

## ТЕСТ 2: Граф с несколькими путями

### Описание
Граф, где между парами вершин существуют несколько различных путей.

### Граф
```
    ┌──7──┐
    ↓     |
    0 --3-> 1 --2-> 2
    ↑       ↓       |
    └──8────┘       1
                    ↓
    ┌───────────────3
    ↓               ↑
    2 <-----5------- 0
    |               |
    4               6
    ↓               ↓
    3 <-----2------- 4
```

### Особенности
- Множество альтернативных путей между вершинами
- Алгоритм находит оптимальные маршруты
- Демонстрирует важность рассмотрения промежуточных вершин

### Применение
Моделирование транспортных сетей, где есть множество альтернативных маршрутов.

---

## ТЕСТ 3: Полный граф

### Описание
Граф с 5 вершинами и множеством рёбер (запускается без детального вывода).

### Особенности
- Плотный граф с E ≈ V²
- Показывает эффективность алгоритма на плотных структурах
- Множество прямых связей между вершинами

### Применение
- Телекоммуникационные сети с множественными связями
- Социальные сети с высокой связностью

---

## ТЕСТ 4: Граф с отрицательными весами

### Описание
Демонстрирует работу с отрицательными весами рёбер (без отрицательных циклов).

### Граф
```
    0 --2--> 1 ---(-3)---> 2 --2--> 3
    |                               ↑
    └──────────────5────────────────┘
```

### Особенности
- Ребро 1→2 имеет отрицательный вес -3
- Путь 0→1→2→3 короче, чем 0→3, несмотря на большее количество рёбер
- Алгоритм корректно обрабатывает отрицательные веса

### Математика
- Прямой путь 0→3: вес = 5
- Путь через 1,2: 2 + (-3) + 2 = **1** ✓ (короче!)

### Применение
- Финансовые системы (отрицательные веса = скидки, бонусы)
- Игровая теория (штрафы и награды)

---

## ТЕСТ 5: Граф с отрицательным циклом ⚠️

### Описание
**Критический тест**: обнаружение отрицательного цикла в графе.

### Граф
```
    0 --1--> 1
    ↑        |
    |      (-3)
    (-2)     ↓
    └────────2
```

### Цикл
```
0 → 1 → 2 → 0
Веса: 1 + (-3) + (-2) = -4 (отрицательный!)
```

### Особенности
- Алгоритм **обнаруживает** отрицательный цикл
- После завершения dist[i][i] < 0 для вершин в цикле
- Кратчайшие пути не определены (можно проходить цикл бесконечно)

### Проверка
```cpp
for (int i = 0; i < V; i++) {
    if (dist[i][i] < 0) {
        cout << "Отрицательный цикл в вершине " << i << endl;
    }
}
```

### Применение
- Обнаружение арбитража в финансовых системах
- Выявление логических противоречий
- Проверка корректности данных

---

## ТЕСТ 6: Несвязный граф

### Описание
Граф, состоящий из нескольких изолированных компонент связности.

### Граф
```
Компонента 1:    Компонента 2:
    0 <--2--> 1      2 <--5--> 3
```

### Матрица расстояний (результат)
```
     0   1   2   3
   ----------------
0 |  0   2   ∞   ∞
1 |  2   0   ∞   ∞
2 |  ∞   ∞   0   5
3 |  ∞   ∞   5   0
```

### Особенности
- Расстояния между компонентами = ∞ (недостижимы)
- Алгоритм корректно определяет недостижимость
- MST не существует для такого графа

### Применение
- Анализ связности сети
- Обнаружение изолированных подсистем
- Проверка достижимости в распределённых системах

---

## ТЕСТ 7: Граф-звезда (Star Graph)

### Описание
Топология, где все вершины соединены только с центральной вершиной.

### Граф
```
        1
        |3
    2---0---4
      5 |1 2
        3
```

### Особенности
- Центральная вершина 0 — единственный связующий элемент
- Путь между любыми двумя периферийными вершинами проходит через центр
- Расстояние между вершинами i и j: weight(i,0) + weight(0,j)

### Результаты
- Путь 1→2: `1 → 0 → 2` (длина: 3 + 5 = 8)
- Путь 3→4: `3 → 0 → 4` (длина: 1 + 2 = 3)

### Применение
- Централизованные сети (клиент-сервер)
- Системы с единой точкой маршрутизации
- Организационные иерархии

---

## ТЕСТ 8: Транзитивное замыкание (единичные веса)

### Описание
Все рёбра имеют вес 1 — аналог работы с невзвешенным графом (как BFS).

### Граф
```
    0 ---1--- 1 ---1--- 2 ---1--- 3 ---1--- 4
    |                    ↑
    └────────1───────────┘
```

### Особенности
- Результат показывает **минимальное количество рёбер** в пути
- Эквивалентно вычислению транзитивного замыкания
- Можно использовать для анализа графа достижимости

### Результаты
- Путь 0→2: прямое ребро (1 ребро)
- Путь 0→3: через 2 (2 ребра)
- Путь 0→4: минимум 3 ребра

### Применение
- Анализ степени разделения в социальных сетях
- Подсчёт хопов в компьютерных сетях
- Вычисление диаметра графа

---

## ТЕСТ 9: Нарушение треугольного неравенства

### Описание
Демонстрирует случай, когда прямой путь длиннее, чем путь через промежуточную вершину.

### Граф
```
    0 -----10-----> 2
     \             ↗
      2         3
       ↘      ↗
         1
```

### Математика
```
Прямой путь:        0 → 2         = 10
Путь через 1:       0 → 1 → 2     = 2 + 3 = 5 ✓
```

### Треугольное неравенство
В метрических пространствах: `dist(A,C) ≤ dist(A,B) + dist(B,C)`

Здесь нарушено: `10 > 2 + 3`, поэтому алгоритм находит более короткий путь.

### Особенности
- Классический пример оптимизации пути
- Показывает суть динамического программирования
- Иллюстрирует, почему нужно проверять промежуточные вершины

### Применение
- Оптимизация маршрутов с пересадками
- Финансовые транзакции через посредников
- Логистические цепочки

---

## ТЕСТ 10: Симметричный граф (неориентированный)

### Описание
Эмуляция неориентированного графа через симметричные рёбра.

### Граф
```
Неориентированный граф с 4 вершинами:

    0 (вершина)
   / \
  2   3  (веса рёбер)
 /     \
1       2 (вершины)
 \     /
  4   1  (веса рёбер)
   \ /
    3 (вершина)

Рёбра: 0-1(2), 0-2(3), 1-3(4), 2-3(1)
```

### Реализация
```cpp
// Для неориентированного графа добавляем рёбра в обе стороны
g.addEdge(0, 1, 2);
g.addEdge(1, 0, 2);  // Обратное ребро с тем же весом
```

### Особенности
- Матрица расстояний симметрична: `dist[i][j] = dist[j][i]`
- Алгоритм работает одинаково хорошо
- Можно оптимизировать: считать только половину матрицы

### Применение
- Дорожные сети (двусторонние дороги)
- Социальные связи (дружба взаимна)
- Физические соединения

---

## ТЕСТ 11: Длинная цепь с обратным ребром

### Описание
Длинная цепь рёбер с одним коротким обратным ребром, создающим интересные пути.

### Граф
```
    0 ---1--> 1 ---1--> 2 ---1--> 3 ---1--> 4
    |                                        ↑
    └----------------2-----------------------┘
    ↑                                        |
    └------------------10--------------------┘
```

### Особенности
- Прямой путь 0→4: через цепь (сумма: 4) или прямое ребро (10)
- Обратный путь 4→0: короткое ребро (2)
- Путь 4→1: через 4→0→1 короче, чем 4→3→2→1

### Результаты
```
Путь 0→4: 0 → 1 → 2 → 3 → 4 (длина: 4)  ✓ вместо прямого (10)
Путь 4→1: 4 → 0 → 1 (длина: 3)          ✓ вместо обратного (7)
```

### Применение
- Сети с асимметричными связями (спутниковая связь)
- Дороги с односторонним движением
- Оптимизация круговых маршрутов

---

## ТЕСТ 12: Плотный граф (почти полный)

### Описание
Граф с большим количеством рёбер — демонстрирует эффективность на плотных структурах.

### Характеристики
- Вершины: 6
- Рёбра: 12 (из возможных 30 в полном графе)
- Плотность: 40%

### Граф
```
    0 ←──8── 3 ──6─→ 4
   ↙ ↘      ↑       ↓
  7   9     11      9
 ↙     ↘    ↑       ↓
1 ──10─→ 2  |       5
↑        ↓  |     ↗ ↓
|        2  |   3   |
12       ↓  | ↙     |
|        5  ←      9
↓        ↓        ↙
4 ←───────────────┘
```

### Особенности
- Множество альтернативных путей
- Алгоритм эффективен для плотных графов: O(V³) часто лучше, чем V раз запускать Dijkstra
- Запускается без детального вывода (слишком много операций)

### Сравнение сложности
```
Floyd-Warshall:  O(V³) = O(6³) = 216 операций
V × Dijkstra:    O(V × E log V) = O(6 × 12 × log 6) ≈ 130 операций

Но для V=100, E=5000:
Floyd-Warshall:  O(100³) = 1,000,000 операций
V × Dijkstra:    O(100 × 5000 × log 100) ≈ 3,300,000 операций
```

### Применение
- Телекоммуникационные сети с множественными связями
- Транспортные сети в городах
- Полносвязные компьютерные сети

---

## Сравнительная таблица тестов

| Тест | Тип графа | Вершин | Особенность | Уровень |
|------|-----------|--------|-------------|---------|
| 1 | Направленный | 4 | Базовый пример | Начальный |
| 2 | Направленный | 4 | Множество путей | Базовый |
| 3 | Направленный | 5 | Полный граф | Средний |
| 4 | Направленный | 4 | Отрицательные веса | Средний |
| 5 | Направленный | 3 | Отрицательный цикл ⚠️ | Продвинутый |
| 6 | Направленный | 4 | Несвязный | Средний |
| 7 | Направленный | 5 | Звезда | Базовый |
| 8 | Направленный | 5 | Единичные веса | Базовый |
| 9 | Направленный | 3 | Треугольное неравенство | Средний |
| 10 | Неориентированный | 4 | Симметричный | Базовый |
| 11 | Направленный | 5 | Асимметричные связи | Продвинутый |
| 12 | Направленный | 6 | Плотный граф | Средний |

---

## Как запустить примеры

### Компиляция
```bash
cd floyd_warshall
g++ -std=c++11 -Wall -Wextra -O2 -o floyd_warshall simple_floyd_warshall.cxx
```

### Запуск
```bash
./floyd_warshall
```

### Запуск с перенаправлением вывода
```bash
./floyd_warshall > output.txt
```

### Запуск конкретного теста
Можно модифицировать `main()`, закомментировав ненужные тесты:
```cpp
int main() {
    // Запускаем только тест 5
    Graph g5(3, true);
    g5.addEdge(0, 1, 1);
    g5.addEdge(1, 2, -3);
    g5.addEdge(2, 0, -2);
    g5.floydWarshall();
    return 0;
}
```

---

## Образовательные цели

### Для студентов
1. **Понимание алгоритма**: verbose режим показывает каждый шаг
2. **Различные сценарии**: от простых до сложных случаев
3. **Практическое применение**: реальные примеры использования
4. **Отладка**: учимся проверять корректность работы

### Для преподавателей
1. **Демонстрация на доске**: примеры с малым количеством вершин
2. **Сравнение подходов**: Floyd-Warshall vs Dijkstra vs BFS
3. **Граничные случаи**: отрицательные циклы, несвязные графы
4. **Анализ сложности**: практическая демонстрация O(V³)

---

## Дополнительные эксперименты

### Эксперимент 1: Измерение времени
```cpp
#include <chrono>

auto start = chrono::high_resolution_clock::now();
g.floydWarshall();
auto end = chrono::high_resolution_clock::now();
auto duration = chrono::duration_cast<chrono::microseconds>(end - start);
cout << "Время выполнения: " << duration.count() << " мкс" << endl;
```

### Эксперимент 2: Случайные графы
```cpp
// Создаём случайный граф
srand(time(0));
Graph g(20, false);
for (int i = 0; i < 20; i++) {
    for (int j = 0; j < 20; j++) {
        if (i != j && rand() % 3 == 0) {  // 33% вероятность ребра
            g.addEdge(i, j, rand() % 100 + 1);
        }
    }
}
g.floydWarshall();
```

### Эксперимент 3: Вычисление диаметра графа
```cpp
// Диаметр = максимальное кратчайшее расстояние между любыми двумя вершинами
int diameter = 0;
for (int i = 0; i < V; i++) {
    for (int j = 0; j < V; j++) {
        if (dist[i][j] != INT_MAX && dist[i][j] > diameter) {
            diameter = dist[i][j];
        }
    }
}
cout << "Диаметр графа: " << diameter << endl;
```

---

## Полезные модификации

### 1. Подсчёт количества путей
```cpp
// Добавляем матрицу для подсчёта путей
vector<vector<int>> pathCount;
// При обновлении расстояния:
if (dist[i][k] + dist[k][j] < dist[i][j]) {
    pathCount[i][j] = pathCount[i][k] * pathCount[k][j];
}
```

### 2. Максимальная пропускная способность
```cpp
// Находим путь с максимальной минимальной пропускной способностью
// Заменяем: + на min, min на max
capacity[i][j] = max(capacity[i][j], 
                      min(capacity[i][k], capacity[k][j]));
```

### 3. Проверка достижимости
```cpp
// Транзитивное замыкание (модификация Уоршелла)
for (int k = 0; k < V; k++)
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++)
            reach[i][j] = reach[i][j] || (reach[i][k] && reach[k][j]);
```

---

## Контрольные вопросы

1. Почему алгоритм находит кратчайший путь 0→2→3 вместо прямого 0→3?
2. Как алгоритм обнаруживает отрицательный цикл?
3. Что означает ∞ в матрице расстояний?
4. Почему сложность O(V³), а не O(E·V)?
5. Можно ли использовать Floyd-Warshall для ориентированных графов?
6. Чем отличается работа алгоритма на плотных и разреженных графах?
7. Как восстановить сам путь, а не только его длину?
8. Когда Floyd-Warshall лучше, чем V раз запустить Dijkstra?

---

## Резюме

Эти 12 примеров покрывают практически все основные сценарии использования алгоритма Флойда-Уоршелла:
- ✅ Базовые графы
- ✅ Отрицательные веса
- ✅ Отрицательные циклы
- ✅ Несвязные графы
- ✅ Различные топологии
- ✅ Плотные графы
- ✅ Асимметричные связи
- ✅ Практические применения

Используйте их для обучения, отладки и понимания работы алгоритма!

