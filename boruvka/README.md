# Алгоритм Борувки (Borůvka's Algorithm)

## Описание

Алгоритм Борувки — это итеративный алгоритм для построения **минимального остовного дерева (MST)** в связном неориентированном взвешенном графе. MST — это подграф, который соединяет все вершины с минимальной суммой весов рёбер и не содержит циклов.

## Ключевые особенности

- **Итеративный алгоритм**: на каждой итерации обрабатывает все компоненты связности
- **Параллелизуемый**: поиск минимальных рёбер для компонентов независим
- **Использует Union-Find**: для управления компонентами связности
- **Временная сложность**: O(E log V) — максимум log V итераций
- **Пространственная сложность**: O(V + E)
- **Лучше для параллельных вычислений**: чем алгоритмы Прима и Крускала

## Минимальное остовное дерево (MST)

### Определение
**Остовное дерево** (spanning tree) графа G — это подграф, который:
1. Включает **все вершины** графа G
2. Является **деревом** (связный граф без циклов)
3. Содержит **V-1 рёбер**, где V — количество вершин

**Минимальное остовное дерево** (MST) — это остовное дерево с минимальной суммой весов рёбер.

### Свойства MST
- В связном графе с V вершинами MST содержит ровно **V-1 рёбер**
- Если все веса рёбер различны, MST **единственно**
- Удаление любого ребра из MST делает граф **несвязным**
- Добавление любого ребра в MST создаёт **цикл**

## Как работает алгоритм

### Основная идея

1. На каждой итерации находим минимальное ребро для каждого компонента связности
2. Добавляем найденные рёбра в MST
3. Объединяем компоненты, соединённые добавленными рёбрами
4. Повторяем, пока не останется один компонент

### Алгоритм (псевдокод)

```
1. Инициализация:
   - Инициализируем Union-Find структуру (каждая вершина - отдельный компонент)
   - MST = пустое множество

2. Пока количество компонентов > 1:
   a) Для каждого компонента C:
      - Находим минимальное ребро, выходящее из C (соединяющее C с другим компонентом)
      - Сохраняем это ребро в cheapest[C]
   
   b) Для каждого компонента C:
      - Если cheapest[C] существует и соединяет C с другим компонентом:
        * Добавляем cheapest[C] в MST
        * Объединяем компоненты через это ребро

3. MST построено
```

## Пример работы

### Граф
```
    0
   /|\
  1 4 2
   \ /
    2
    |
    3
```

Веса рёбер: 0-1: 1, 0-2: 4, 1-2: 2, 2-3: 1

### Шаги алгоритма

**Итерация 1:**
- Компоненты: {0}, {1}, {2}, {3}
- Минимальные рёбра:
  - Компонент {0}: 0-1(1)
  - Компонент {1}: 0-1(1) или 1-2(2) → выбираем 0-1(1)
  - Компонент {2}: 2-3(1) или 1-2(2) → выбираем 2-3(1)
  - Компонент {3}: 2-3(1)
- Добавляем: 0-1(1), 2-3(1)
- Компоненты после объединения: {0,1}, {2,3}

**Итерация 2:**
- Компоненты: {0,1}, {2,3}
- Минимальные рёбра:
  - Компонент {0,1}: 1-2(2)
  - Компонент {2,3}: 1-2(2)
- Добавляем: 1-2(2)
- Компоненты после объединения: {0,1,2,3}
- **Готово!** (один компонент)

### Результат
```
MST рёбра: 0-1(1), 2-3(1), 1-2(2)
Общий вес: 4
Количество итераций: 2
```

## Сравнение с другими алгоритмами MST

| Алгоритм | Подход | Сложность | Лучше для |
|----------|--------|-----------|-----------|
| **Prim** | Жадный (растёт от вершины) | O(E log V) | Плотные графы |
| **Kruskal** | Жадный (сортирует рёбра) | O(E log E) | Разреженные графы |
| **Borůvka** | Параллельный | O(E log V) | Параллельные вычисления |

## Сравнение Борувки с другими алгоритмами

| Параметр | Borůvka | Prim | Kruskal |
|----------|---------|------|---------|
| **Подход** | Итеративный (по компонентам) | Растёт от вершины | Сортирует рёбра |
| **Структура данных** | Union-Find | Приоритетная очередь | Union-Find + сортировка |
| **Сложность** | O(E log V) | O(E log V) | O(E log E) |
| **Параллелизация** | Легко (независимые компоненты) | Сложнее | Средне (сортировка) |
| **Итераций** | O(log V) | O(V) | 1 (после сортировки) |
| **Память** | O(V + E) | O(V + E) | O(V + E) |

## Когда использовать

### ✅ Хорошо подходит для:
- Параллельных вычислений (легко распараллелить поиск минимальных рёбер)
- Распределённых систем
- Когда нужно обрабатывать компоненты независимо
- Больших графов с хорошей параллелизацией
- Когда количество итераций важно (максимум log V)

### ❌ Не подходит для:
- Несвязных графов (MST не существует)
- Ориентированных графов
- Когда нужна простая последовательная реализация
- Когда важна простота кода (алгоритм сложнее Прима и Крускала)

## Применение

1. **Сетевой дизайн**
   - Прокладка электрических/телефонных линий
   - Проектирование трубопроводов
   - Компьютерные сети

2. **Параллельные вычисления**
   - Распределённые системы
   - Кластерные вычисления
   - GPU-ускорение

3. **Кластерный анализ**
   - Группировка данных
   - Сегментация изображений

4. **Приближённые алгоритмы**
   - Задача коммивояжёра (TSP)
   - Задача Штейнера

5. **Биоинформатика**
   - Анализ генетических данных
   - Построение филогенетических деревьев

## Компиляция и запуск

```bash
# Компиляция
g++ -std=c++11 -o boruvka simple_boruvka.cxx

# Запуск
./boruvka
```

## Особенности реализации

### Режим verbose
Программа поддерживает детальный вывод:
- Показывает каждую итерацию
- Выводит состояние Union-Find структуры
- Показывает найденные минимальные рёбра для каждого компонента
- Визуализирует текущее состояние MST

### Union-Find (Disjoint Set Union)
Используется для управления компонентами связности:
- **Path compression**: оптимизация операции find
- **Union by rank**: оптимизация операции union
- Сложность операций: почти O(1) амортизированно

### Поиск минимальных рёбер
На каждой итерации для каждого компонента находится минимальное ребро, выходящее из него. Это можно легко распараллелить.

### Проверка корректности
После построения MST проверяется, что количество рёбер равно V-1.

## Временная сложность

- **O(E log V)**: основная сложность
  - Максимум **log V итераций** (на каждой итерации количество компонентов уменьшается минимум вдвое)
  - На каждой итерации проходим по всем рёбрам: **O(E)**
  - Операции Union-Find: **O(α(V))** амортизированно (практически константа)
- **Итого**: O(E log V)

Для разреженных графов (E ≈ V): O(V log V)
Для плотных графов (E ≈ V²): O(V² log V)

## Пространственная сложность

- **O(V)**: для Union-Find структуры (parent, rank)
- **O(E)**: для хранения списка рёбер
- **O(V)**: для массива cheapest (минимальные рёбра для компонентов)
- **O(V)**: для хранения рёбер MST
- **Итого**: O(V + E)

## Корректность алгоритма

### Теорема (Cut Property)
Пусть S ⊂ V — подмножество вершин графа. Если ребро e имеет минимальный вес среди всех рёбер, соединяющих S и V\S, то e принадлежит некоторому MST.

### Доказательство
Алгоритм Борувки на каждой итерации для каждого компонента выбирает минимальное ребро, выходящее из него. По Cut Property, такие рёбра обязательно войдут в некоторое MST.

### Почему максимум log V итераций?
На каждой итерации каждый компонент объединяется хотя бы с одним другим компонентом через минимальное ребро. В худшем случае количество компонентов уменьшается вдвое на каждой итерации, поэтому максимум log V итераций.

## Вариации алгоритма

### 1. Параллельная версия
```cpp
// Для каждого компонента параллельно находим минимальное ребро
#pragma omp parallel for
for (int component = 0; component < numComponents; component++) {
    findMinEdge(component);
}
```

### 2. Версия с оптимизацией дубликатов
На каждой итерации может быть найдено одно и то же ребро для разных компонентов. Можно оптимизировать, чтобы не добавлять дубликаты.

## Оптимизации

1. **Path compression**: оптимизация Union-Find
2. **Union by rank**: оптимизация Union-Find
3. **Ранняя остановка**: когда остался один компонент
4. **Параллельный поиск**: минимальных рёбер для компонентов
5. **Кэширование**: результатов поиска минимальных рёбер

## Интересные факты

- Назван в честь Отокара Борувки (1926)
- Один из первых алгоритмов для MST
- Первоначально разработан для решения задачи электрификации Моравии
- Легко параллелизуется, что делает его популярным в распределённых системах
- Количество итераций гарантированно не превышает log V

## Связь с другими алгоритмами

- **Алгоритм Прима**: другой подход к MST (растёт от вершины)
- **Алгоритм Крускала**: другой подход к MST (сортирует рёбра)
- **Union-Find**: структура данных для непересекающихся множеств
- **Параллельные алгоритмы**: Борувка — классический пример параллелизуемого алгоритма

## Дополнительные задачи

1. Модифицировать для поиска максимального остовного дерева
2. Найти второе по величине MST
3. Вычислить bottleneck spanning tree
4. Построить MST с ограничениями (degree-constrained MST)
5. Динамический MST (обновление при добавлении/удалении рёбер)
6. Полностью параллельная версия алгоритма
7. GPU-ускоренная версия

## Доказательство оптимальности

### Лемма о безопасном ребре
Если A — подмножество некоторого MST, и (u,v) — лёгкое ребро, пересекающее разрез (S, V-S), где A не пересекает разрез, то (u,v) безопасно для A.

**Алгоритм Борувки** на каждой итерации для каждого компонента выбирает минимальное ребро, выходящее из него. По Cut Property, такие рёбра безопасны и обязательно войдут в некоторое MST.

## Параллелизация

Алгоритм Борувки особенно хорошо подходит для параллелизации:

1. **Независимость компонентов**: поиск минимального ребра для каждого компонента не зависит от других компонентов
2. **Масштабируемость**: можно использовать столько потоков, сколько компонентов
3. **Простота**: параллелизация не требует сложной синхронизации

### Пример параллельной реализации
```cpp
// Псевдокод параллельной версии
while (components > 1) {
    #pragma omp parallel for
    for (each component C) {
        cheapest[C] = findMinEdge(C);
    }
    
    #pragma omp parallel for
    for (each component C) {
        if (cheapest[C] connects different components) {
            addToMST(cheapest[C]);
            union(components);
        }
    }
}
```

