# Алгоритм Крускала (Kruskal's Algorithm)

## Описание

Алгоритм Крускала — это жадный алгоритм для построения **минимального остовного дерева (MST)** в связном неориентированном взвешенном графе. MST — это подграф, который соединяет все вершины с минимальной суммой весов рёбер и не содержит циклов.

## Ключевые особенности

- **Жадный алгоритм**: на каждом шаге выбирает ребро с минимальным весом
- **Использует сортировку рёбер**: все рёбра сортируются по весу
- **Использует Union-Find**: для эффективной проверки циклов
- **Временная сложность**: O(E log E) из-за сортировки
- **Пространственная сложность**: O(V + E)
- **Лучше для разреженных графов**: чем алгоритм Прима

## Минимальное остовное дерево (MST)

### Определение
**Остовное дерево** (spanning tree) графа G — это подграф, который:
1. Включает **все вершины** графа G
2. Является **деревом** (связный граф без циклов)
3. Содержит **V-1 рёбер**, где V — количество вершин

**Минимальное остовное дерево** (MST) — это остовное дерево с минимальной суммой весов рёбер.

### Свойства MST
- В связном графе с V вершинами MST содержит ровно **V-1 рёбер**
- Если все веса рёбер различны, MST **единственно**
- Удаление любого ребра из MST делает граф **несвязным**
- Добавление любого ребра в MST создаёт **цикл**

## Как работает алгоритм

### Основная идея

1. Сортируем все рёбра графа по весу (по возрастанию)
2. Проходим по отсортированным рёбрам
3. Добавляем ребро в MST, если оно не создаёт цикл
4. Повторяем, пока не добавим V-1 рёбер

### Алгоритм (псевдокод)

```
1. Инициализация:
   - Создаём список всех рёбер
   - Сортируем рёбра по весу (по возрастанию)
   - Инициализируем Union-Find структуру (каждая вершина - отдельное множество)

2. Для каждого ребра (u, v) в отсортированном порядке:
   a) Если find(u) != find(v) (вершины в разных множествах):
      - Добавляем ребро (u, v) в MST
      - Объединяем множества: union(u, v)
   b) Иначе (вершины в одном множестве):
      - Пропускаем ребро (создастся цикл)

3. MST построено (когда добавлено V-1 рёбер)
```

## Пример работы

### Граф
```
    0
   /|\
  1 4 2
   \ /
    2
    |
    3
```

Веса рёбер: 0-1: 1, 0-2: 4, 1-2: 2, 2-3: 1

### Шаги алгоритма

1. **Сортировка рёбер**: 0-1(1), 2-3(1), 1-2(2), 0-2(4)

2. **Шаг 1**: добавляем ребро 0-1 (вес 1)
   - MST: {0-1}
   - Множества: {0,1}, {2}, {3}

3. **Шаг 2**: добавляем ребро 2-3 (вес 1)
   - MST: {0-1, 2-3}
   - Множества: {0,1}, {2,3}

4. **Шаг 3**: добавляем ребро 1-2 (вес 2)
   - MST: {0-1, 2-3, 1-2}
   - Множества: {0,1,2,3}
   - **Готово!** (V-1 = 3 рёбра)

5. **Шаг 4**: пропускаем ребро 0-2 (создастся цикл)

### Результат
```
MST рёбра: 0-1(1), 2-3(1), 1-2(2)
Общий вес: 4
```

## Сравнение с другими алгоритмами MST

| Алгоритм | Подход | Сложность | Лучше для |
|----------|--------|-----------|-----------|
| **Prim** | Жадный (растёт от вершины) | O(E log V) | Плотные графы |
| **Kruskal** | Жадный (сортирует рёбра) | O(E log E) | Разреженные графы |
| **Borůvka** | Параллельный | O(E log V) | Параллельные вычисления |

## Сравнение Крускала и Прима

| Параметр | Kruskal | Prim |
|----------|---------|------|
| **Подход** | Сортирует рёбра | Растёт от вершины |
| **Структура данных** | Union-Find | Приоритетная очередь |
| **Сложность** | O(E log E) | O(E log V) |
| **Лучше для** | Разреженные графы (E ≈ V) | Плотные графы (E ≈ V²) |
| **Память** | O(V + E) | O(V + E) |
| **Параллелизация** | Легко (сортировка) | Сложнее |

## Когда использовать

### ✅ Хорошо подходит для:
- Разреженных графов (мало рёбер относительно вершин)
- Когда рёбра уже отсортированы или легко сортируются
- Параллельных вычислений (сортировка легко параллелизуется)
- Когда нужно построить MST из списка рёбер
- Построения сетей с минимальной стоимостью

### ❌ Не подходит для:
- Несвязных графов (MST не существует)
- Ориентированных графов
- Плотных графов (лучше использовать Prim)
- Когда нужны пути между конкретными вершинами

## Применение

1. **Сетевой дизайн**
   - Прокладка электрических/телефонных линий
   - Проектирование трубопроводов
   - Компьютерные сети

2. **Кластерный анализ**
   - Группировка данных
   - Сегментация изображений

3. **Приближённые алгоритмы**
   - Задача коммивояжёра (TSP)
   - Задача Штейнера

4. **Биоинформатика**
   - Анализ генетических данных
   - Построение филогенетических деревьев

5. **География**
   - Планирование дорог
   - Оптимизация маршрутов

## Компиляция и запуск

```bash
# Компиляция
g++ -std=c++11 -o kruskal simple_kruskal.cxx

# Запуск
./kruskal
```

## Особенности реализации

### Режим verbose
Программа поддерживает детальный вывод:
- Показывает отсортированные рёбра
- Выводит состояние Union-Find структуры
- Показывает каждое рассматриваемое ребро
- Визуализирует текущее состояние MST

### Union-Find (Disjoint Set Union)
Используется для эффективной проверки циклов:
- **Path compression**: оптимизация операции find
- **Union by rank**: оптимизация операции union
- Сложность операций: почти O(1) амортизированно

### Проверка корректности
После построения MST проверяется, что количество рёбер равно V-1.

## Временная сложность

- **O(E log E)**: основная сложность из-за сортировки рёбер
- **O(E α(V))**: операции Union-Find (α - обратная функция Аккермана, практически константа)
- **Итого**: O(E log E) = O(E log V) для связных графов (E ≥ V-1)

Для разреженных графов (E ≈ V): O(V log V)
Для плотных графов (E ≈ V²): O(V² log V)

## Пространственная сложность

- **O(V)**: для Union-Find структуры (parent, rank)
- **O(E)**: для хранения списка рёбер
- **O(V)**: для хранения рёбер MST
- **Итого**: O(V + E)

## Корректность алгоритма

### Теорема (Cut Property)
Пусть S ⊂ V — подмножество вершин графа. Если ребро e имеет минимальный вес среди всех рёбер, соединяющих S и V\S, то e принадлежит некоторому MST.

### Доказательство жадного выбора
Алгоритм Крускала на каждом шаге выбирает ребро с минимальным весом, которое не создаёт цикл. По Cut Property, такое ребро обязательно войдёт в некоторое MST.

## Вариации алгоритма

### 1. Версия с простой проверкой циклов
```cpp
// Использование DFS для проверки циклов (медленнее)
bool createsCycle(int u, int v) {
    // DFS для проверки пути между u и v
    // O(V) для каждой проверки
}
```
Сложность: O(E * V) - медленнее

### 2. Версия с Union-Find (текущая)
- Path compression + Union by rank
- Почти O(1) для операций find/union
- Общая сложность: O(E log E)

## Оптимизации

1. **Path compression**: делает родителя корнем при поиске
2. **Union by rank**: присоединяет меньшее дерево к большему
3. **Ранняя остановка**: когда добавлено V-1 рёбер
4. **Параллельная сортировка**: для очень больших графов

## Интересные факты

- Назван в честь Джозефа Крускала (1956)
- Независимо открыт Лобером и Шварцем (1957)
- Один из первых алгоритмов, использующих жадный подход
- В разреженных графах эффективнее алгоритма Прима
- Легко параллелизуется (сортировка и независимая обработка рёбер)

## Связь с другими алгоритмами

- **Алгоритм Прима**: другой подход к MST (растёт от вершины)
- **Алгоритм Борувки**: параллельная версия MST
- **Union-Find**: структура данных для непересекающихся множеств
- **Жадные алгоритмы**: Kruskal — классический пример жадного подхода

## Дополнительные задачи

1. Модифицировать для поиска максимального остовного дерева
2. Найти второе по величине MST
3. Вычислить bottleneck spanning tree
4. Построить MST с ограничениями (degree-constrained MST)
5. Динамический MST (обновление при добавлении/удалении рёбер)
6. Параллельная версия алгоритма

## Доказательство оптимальности

### Лемма о безопасном ребре
Если A — подмножество некоторого MST, и (u,v) — лёгкое ребро, которое не создаёт цикл в A, то (u,v) безопасно для A.

**Алгоритм Крускала** на каждом шаге добавляет безопасное ребро (минимальное по весу, не создающее цикл), поэтому строит MST.

