# ============================================================
# MAKEFILE ДЛЯ ПРОЕКТА HELLO WORLD
# ============================================================
# Этот файл описывает правила сборки проекта с помощью утилиты make.
# make читает файл Makefile и выполняет команды для сборки программы.
#
# АНАЛИЗ СТРУКТУРЫ MAKEFILE:
# ============================================================

# ------------------------------------------------------------
# 1. ПЕРЕМЕННЫЕ (Variables)
# ------------------------------------------------------------
# Переменные делают Makefile более гибким и читаемым.
# Синтаксис: ИМЯ_ПЕРЕМЕННОЙ = значение
# Использование: $(ИМЯ_ПЕРЕМЕННОЙ) или ${ИМЯ_ПЕРЕМЕННОЙ}

# Компилятор C++
CXX = g++

# Флаги компиляции
# -Wall: включить все предупреждения (all warnings)
# -std=c++17: использовать стандарт C++17
CXXFLAGS = -Wall -std=c++17

# Директория для объектных файлов
BUILD_DIR = build

# Директория для исходников
SRC_DIR = .

# Имя исполняемого файла
TARGET = hello

# Исходные файлы (с расширением .cpp)
SRCS = $(wildcard $(SRC_DIR)/*.cpp)

# Объектные файлы (.o файлы, создаются из .cpp файлов)
# Функция patsubst заменяет расширения: .cpp -> .o
OBJS = $(patsubst $(SRC_DIR)/%.cpp, $(BUILD_DIR)/%.o, $(SRCS))

# ------------------------------------------------------------
# 2. ПРАВИЛА (Rules)
# ------------------------------------------------------------
# Правило имеет формат:
#   цель: зависимости
#       команда
#       команда
#
# Цель (target) - что мы хотим создать
# Зависимости (prerequisites) - что нужно для создания цели
# Команды (recipes) - действия для создания цели
#
# ВАЖНО: команды должны начинаться с символа TAB, а не пробелов!

# ------------------------------------------------------------
# 3. ПЕРВОЕ ПРАВИЛО (Default Target)
# ------------------------------------------------------------
# Это правило будет выполняться при вызове `make` без аргументов
# .PHONY означает, что "all" - это не реальный файл, а просто команда
.PHONY: all
all: $(TARGET)

# ------------------------------------------------------------
# 4. ПРАВИЛО ДЛЯ СОЗДАНИЯ ИСПОЛНЯЕМОГО ФАЙЛА
# ------------------------------------------------------------
# Цель: $(TARGET) - создаем файл "hello"
# Зависимости: $(OBJS) - нужны все объектные файлы
# Команда: $(CXX) -c $(CXXFLAGS) - линковка объектных файлов в исполняемый

$(TARGET): $(OBJS)
	# Создаем ссылку (компилируем и линкуем) объектные файлы в исполняемый
	$(CXX) $(OBJS) -o $(TARGET)
	@echo "============================================"
	@echo "Сборка завершена!"
	@echo "Запустите: ./$(TARGET)"
	@echo "============================================"

# ------------------------------------------------------------
# 5. ПРАВИЛО ДЛЯ СОЗДАНИЯ ОБЪЕКТНЫХ ФАЙЛОВ
# ------------------------------------------------------------
# Цель: $(BUILD_DIR)/%.o - создаем файл в директории build
# Зависимости: %.cpp - исходный .cpp файл
# 
# % - это шаблон (pattern), который matchит любую строку
# Это правило применится к любому .cpp файлу

$(BUILD_DIR)/%.o: %.cpp
	# Создаем директорию, если её нет
	@mkdir -p $(BUILD_DIR)
	# Компилируем .cpp в .o (объектный файл)
	# -c: только компиляция, без линковки
	$(CXX) $(CXXFLAGS) -c $< -o $@
	@echo "Компилирован: $@"

# ------------------------------------------------------------
# 6. СЛУЖЕБНЫЕ ПРАВИЛА
# ------------------------------------------------------------

# Создание директории для сборки
$(BUILD_DIR):
	@mkdir -p $(BUILD_DIR)

# Правило для очистки (удаление скомпилированных файлов)
.PHONY: clean
clean:
	# Удаляем директорию build и исполняемый файл
	rm -rf $(BUILD_DIR) $(TARGET)
	@echo "Очистка завершена"

# Правило для пересборки (очистка + сборка)
.PHONY: rebuild
rebuild: clean all

# Правило для запуска программы
.PHONY: run
run: $(TARGET)
	@echo "Запуск программы..."
	./$(TARGET)

# Правило для вывода информации о проекте
.PHONY: info
info:
	@echo "============================================"
	@echo "ИНФОРМАЦИЯ О ПРОЕКТЕ"
	@echo "============================================"
	@echo "Компилятор: $(CXX)"
	@echo "Флаги: $(CXXFLAGS)"
	@echo "Цель: $(TARGET)"
	@echo "Исходники: $(SRCS)"
	@echo "Объектные файлы: $(OBJS)"
	@echo "============================================"

# ------------------------------------------------------------
# 7. АВТОМАТИЧЕСКИЕ ПЕРЕМЕННЫЕ
# ------------------------------------------------------------
# В правилах make предоставляет специальные переменные:
#
# $@  - имя цели (target)
# $<  - первая зависимость
# $^  - все зависимости
# $?  - зависимости, которые новее цели
# $*  - шаблон, который был найден в %
#
# Примеры использования см. в правиле выше для .o файлов

# ------------------------------------------------------------
# 8. КАК РАБОТАЕТ MAKE
# ------------------------------------------------------------
# 
# 1. make читает Makefile
# 2. Определяет, что нужно сделать (цель)
# 3. Проверяет зависимости
# 4. Если файл-зависимость не существует или старше цели,
#    make выполняет команды для создания зависимости
# 5. Когда все зависимости готовы, выполняет команды цели
#
# Пример работы:
#   make         -> запустит правило "all" -> попытается создать $(TARGET)
#   $(TARGET)    -> зависит от $(OBJS) -> проверит объектные файлы
#   .o файлы     -> зависят от .cpp -> скомпилирует .cpp в .o
#   Затем        -> слинкует .o файлы в исполняемый
#
# КОМАНДЫ:
#   make         - собрать проект
#   make clean   - очистить скомпилированные файлы
#   make rebuild - пересобрать проект
#   make run     - собрать и запустить
#   make info    - показать информацию о проекте

