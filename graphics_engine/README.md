# Софтверный графический движок

Полнофункциональный софтверный графический движок, реализованный на C++.

## Структура проекта

```
graphics_engine/
├── core/                    # Ядро движка
│   ├── math/               # Математические утилиты
│   │   ├── vector3.h/cpp   # 3D векторы
│   │   └── matrix4.h/cpp   # Матрицы 4x4 (повороты, перенос, масштаб)
│   ├── renderer/           # Рендерер
│   │   └── framebuffer.h/cpp # Буфер кадра + Z-buffer
│   └── camera/             # Камера
│       └── camera.h/cpp
│
├── rasterization/          # Растеризация
│   ├── bresenham/          # Алгоритм Брезенхема
│   │   ├── line.h/cpp      # Линии
│   │   └── circle.h/cpp    # Окружности
│   └── polygons/           # Полигоны
│       └── fill.h/cpp       # Заполнение (scanline, flood fill)
│
├── textures/               # Текстурирование
│   └── texture.h/cpp       # Текстуры + билинейная фильтрация
│
├── lighting/               # Освещение
│   ├── phong.h/cpp         # Модель Фонга
│   └── gouraud.h/cpp       # Модель Гуро
│
├── geometry/               # Геометрия
│   ├── transforms/         # Аффинные преобразования
│   │   └── affine.h/cpp    # Повороты, перенос, масштаб
│   ├── normals/            # Расчет нормалей
│   │   └── normals.h/cpp   # Нормали треугольников и мешей
│   ├── generators/         # Генераторы 3D геометрии
│   │   └── mesh_generator.h/cpp # Тор, сфера, куб, цилиндр
│   └── clipping/           # Отсечение
│       └── clipping.h/cpp   # Коэн-Сазерленд, back-face culling
│
└── examples/               # Примеры
    ├── basic_example.cpp    # Базовый пример
    └── torus_example.cpp    # Пример с тором
```

## Реализованные компоненты

### Математика и преобразования

**Матрицы 4x4:**
- ✅ Повороты вокруг осей X, Y, Z
- ✅ Поворот вокруг произвольной оси (формула Родрига)
- ✅ Эйлеровы углы (yaw, pitch, roll)
- ✅ Перенос (translation)
- ✅ Масштабирование (scale)
- ✅ Перспективная проекция
- ✅ Ортогональная проекция
- ✅ LookAt матрица (вид камеры)
- ✅ Умножение на точки и векторы
- ✅ Транспонирование

**Аффинные преобразования:**
- ✅ Преобразование точек
- ✅ Преобразование векторов
- ✅ Преобразование нормалей (обратная транспонированная)
- ✅ Композиция преобразований (T * R * S)
- ✅ Декомпозиция матриц
- ✅ Поворот точки вокруг оси
- ✅ Поворот точки вокруг точки

### Расчет нормалей

- ✅ Нормаль треугольника
- ✅ Нормаль многоугольника (метод Newell)
- ✅ Нормали вершин меша (среднее нормалей граней)
- ✅ Нормализация векторов

### Генераторы 3D геометрии

- ✅ **Тор (тороид)** - полностью реализован
  - Параметры: большой радиус, малый радиус, сегменты
  - Генерирует вершины, нормали, текстурные координаты, индексы
  
- ✅ **Сфера** - полностью реализована
  - Параметры: радиус, сегменты, кольца
  
- ✅ **Куб** - полностью реализован
  - Параметры: размер
  
- ⏳ **Цилиндр** - заготовка
- ⏳ **Конус** - заготовка
- ⏳ **Плоскость** - заготовка

### Растеризация

- ✅ Алгоритм Брезенхема для линий
- ✅ Алгоритм Брезенхема для окружностей
- ✅ Заполнение полигонов (scanline)
- ✅ Flood fill

### Текстурирование

- ✅ Базовый класс Texture
- ✅ Билинейная фильтрация
- ✅ UV-маппинг

### Освещение

- ✅ Модель Фонга (Phong shading)
- ✅ Модель Гуро (Gouraud shading)
- ✅ Диффузное и зеркальное освещение

### Геометрия

- ✅ 3D векторы и матрицы
- ✅ Отсечение линий (Коэн-Сазерленд)
- ✅ Back-face culling
- ✅ Камера с проекцией

### Рендеринг

- ✅ Framebuffer с RGB
- ✅ Z-buffer (depth buffer)
- ✅ Сохранение в BMP

## Использование

### Генерация тора:

```cpp
#include "geometry/generators/mesh_generator.h"

// Создаем тор
Mesh torus = MeshGenerator::generateTorus(
    2.0f,    // Большой радиус
    0.5f,    // Малый радиус
    32,      // Сегментов по большому радиусу
    16       // Сегментов по малому радиусу
);

// Используем вершины и индексы
for (int i = 0; i < torus.numIndices; i += 3)
{
    // Рисуем треугольник
}
```

### Аффинные преобразования:

```cpp
#include "geometry/transforms/affine.h"
#include "core/math/matrix4.h"

// Поворот вокруг оси Y на 45 градусов
Matrix4 rotation = Matrix4::rotationY(M_PI / 4.0f);

// Поворот вокруг произвольной оси
float axis[3] = {1, 1, 0};
Matrix4 rot = Matrix4::rotationAxis(axis, angle);

// Применяем к точке
float point[3] = {1, 0, 0};
float result[3];
AffineTransform::transformPoint(rotation, point, result);
```

### Расчет нормалей:

```cpp
#include "geometry/normals/normals.h"

// Нормаль треугольника
float v0[3] = {0, 0, 0};
float v1[3] = {1, 0, 0};
float v2[3] = {0, 1, 0};
float normal[3];
Normals::calculateTriangleNormal(v0, v1, v2, normal);

// Нормали для всего меша
float* normals = new float[mesh.numVertices * 3];
Normals::calculateMeshNormals(
    mesh.vertices, mesh.numVertices,
    mesh.indices, mesh.numIndices,
    normals
);
```

## Сборка

```bash
cd graphics_engine
mkdir build && cd build
cmake ..
make

# Запуск примеров
./basic_example
./torus_example
```

## Планы развития

- [ ] Загрузка 3D моделей (OBJ формат)
- [ ] Текстурирование с перспективной коррекцией
- [ ] Mip-mapping
- [ ] Тени (shadow mapping)
- [ ] Прозрачность (alpha blending)
- [ ] Антиалиасинг
- [ ] Окружающее освещение (ambient occlusion)
- [ ] Нормальное маппирование (normal mapping)
- [ ] Заполнение треугольников (rasterization)
- [ ] Z-buffer тестирование при рендеринге
